{"version":3,"file":"LiveLocation.js","sourceRoot":"","sources":["../../../../../../front_end/models/bindings/LiveLocation.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,yEAAyE;AACzE,6BAA6B;AAW7B,MAAM,OAAO,oBAAoB;IACvB,cAAc,CAA+C;IACpD,YAAY,CAAmB;IACxC,aAAa,CAAqB;IAE1C,YAAY,cAAqD,EAAE,YAA8B;QAC/F,IAAI,CAAC,cAAc,GAAG,cAAc,CAAC;QACrC,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;QACjC,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;QAE5B,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC;IAC5B,CAAC;IAED,KAAK,CAAC,MAAM;QACV,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE;YACxB,OAAO;SACR;QACD,mEAAmE;QACnE,gEAAgE;QAChE,+DAA+D;QAC/D,IAAI,IAAI,CAAC,aAAa,EAAE;YACtB,MAAM,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC;SACpD;aAAM;YACL,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC;YAC/C,MAAM,IAAI,CAAC,aAAa,CAAC;YACzB,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC;SAC3B;IACH,CAAC;IAED,KAAK,CAAC,UAAU;QACd,MAAM,iBAAiB,CAAC;IAC1B,CAAC;IAED,OAAO;QACL,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QAC/B,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC;IAC7B,CAAC;IAED,KAAK,CAAC,cAAc;QAClB,MAAM,iBAAiB,CAAC;IAC1B,CAAC;CACF;AAED,MAAM,OAAO,gBAAgB;IACV,SAAS,CAAoB;IAE9C;QACE,IAAI,CAAC,SAAS,GAAG,IAAI,GAAG,EAAE,CAAC;IAC7B,CAAC;IAED,GAAG,CAAC,QAAsB;QACxB,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;IAC/B,CAAC;IAED,MAAM,CAAC,QAAsB;QAC3B,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;IAClC,CAAC;IAED,UAAU;QACR,KAAK,MAAM,QAAQ,IAAI,IAAI,CAAC,SAAS,EAAE;YACrC,QAAQ,CAAC,OAAO,EAAE,CAAC;SACpB;IACH,CAAC;CACF","sourcesContent":["// Copyright 2014 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Workspace from '../workspace/workspace.js';\n\nexport interface LiveLocation {\n  update(): Promise<void>;\n  uiLocation(): Promise<Workspace.UISourceCode.UILocation|null>;\n  dispose(): void;\n  isIgnoreListed(): Promise<boolean>;\n}\n\nexport class LiveLocationWithPool implements LiveLocation {\n  private updateDelegate: ((arg0: LiveLocation) => Promise<void>)|null;\n  private readonly locationPool: LiveLocationPool;\n  private updatePromise: Promise<void>|null;\n\n  constructor(updateDelegate: (arg0: LiveLocation) => Promise<void>, locationPool: LiveLocationPool) {\n    this.updateDelegate = updateDelegate;\n    this.locationPool = locationPool;\n    this.locationPool.add(this);\n\n    this.updatePromise = null;\n  }\n\n  async update(): Promise<void> {\n    if (!this.updateDelegate) {\n      return;\n    }\n    // The following is a basic scheduling algorithm, guaranteeing that\n    // {updateDelegate} is always run atomically. That is, we always\n    // wait for an update to finish before we trigger the next run.\n    if (this.updatePromise) {\n      await this.updatePromise.then(() => this.update());\n    } else {\n      this.updatePromise = this.updateDelegate(this);\n      await this.updatePromise;\n      this.updatePromise = null;\n    }\n  }\n\n  async uiLocation(): Promise<Workspace.UISourceCode.UILocation|null> {\n    throw 'Not implemented';\n  }\n\n  dispose(): void {\n    this.locationPool.delete(this);\n    this.updateDelegate = null;\n  }\n\n  async isIgnoreListed(): Promise<boolean> {\n    throw 'Not implemented';\n  }\n}\n\nexport class LiveLocationPool {\n  private readonly locations: Set<LiveLocation>;\n\n  constructor() {\n    this.locations = new Set();\n  }\n\n  add(location: LiveLocation): void {\n    this.locations.add(location);\n  }\n\n  delete(location: LiveLocation): void {\n    this.locations.delete(location);\n  }\n\n  disposeAll(): void {\n    for (const location of this.locations) {\n      location.dispose();\n    }\n  }\n}\n"]}