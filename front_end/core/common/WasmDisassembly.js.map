{"version":3,"file":"WasmDisassembly.js","sourceRoot":"","sources":["../../../../../../front_end/core/common/WasmDisassembly.ts"],"names":[],"mappings":"AAAA,4DAA4D;AAC5D,yEAAyE;AACzE,6BAA6B;AAW7B,MAAM,OAAO,eAAe;IACT,OAAO,CAAW;IAC3B,mBAAmB,CAAuB;IAElD,YAAY,OAAiB,EAAE,mBAAyC;QACtE,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,CAAC,mBAAmB,GAAG,mBAAmB,CAAC;IACjD,CAAC;IAED,IAAI,WAAW;QACb,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC;IAC7B,CAAC;IAED,0BAA0B,CAAC,cAAsB;QAC/C,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAW,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC;QAC/C,OAAO,CAAC,IAAI,CAAC,EAAE;YACb,MAAM,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;YAClC,MAAM,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;YAC/B,IAAI,MAAM,GAAG,cAAc,EAAE;gBAC3B,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;aACX;iBAAM,IAAI,MAAM,GAAG,cAAc,EAAE;gBAClC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;aACX;iBAAM;gBACL,OAAO,CAAC,CAAC;aACV;SACF;QACD,OAAO,CAAC,CAAC;IACX,CAAC;IAED,0BAA0B,CAAC,UAAkB;QAC3C,OAAO,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;IAClC,CAAC;IAED;;OAEG;IACH,CAAE,uBAAuB;QACvB,IAAI,UAAU,GAAG,CAAC,CAAC;QACnB,IAAI,aAAa,GAAG,CAAC,CAAC;QACtB,OAAO,UAAU,GAAG,IAAI,CAAC,WAAW,EAAE;YACpC,IAAI,aAAa,GAAG,IAAI,CAAC,mBAAmB,CAAC,MAAM,EAAE;gBACnD,MAAM,MAAM,GAAG,IAAI,CAAC,0BAA0B,CAAC,UAAU,CAAC,CAAC;gBAC3D,IAAI,MAAM,IAAI,IAAI,CAAC,mBAAmB,CAAC,aAAa,CAAC,CAAC,KAAK,EAAE;oBAC3D,UAAU,GAAG,IAAI,CAAC,0BAA0B,CAAC,IAAI,CAAC,mBAAmB,CAAC,aAAa,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC;oBAC5F,SAAS;iBACV;aACF;YACD,MAAM,UAAU,EAAE,CAAC;SACpB;IACH,CAAC;CACF","sourcesContent":["// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/**\n * Metadata to map between bytecode offsets and line numbers in the\n * disassembly for WebAssembly modules.\n */\n\ninterface FunctionBodyOffset {\n  start: number;\n  end: number;\n}\nexport class WasmDisassembly {\n  private readonly offsets: number[];\n  private functionBodyOffsets: FunctionBodyOffset[];\n\n  constructor(offsets: number[], functionBodyOffsets: FunctionBodyOffset[]) {\n    this.offsets = offsets;\n    this.functionBodyOffsets = functionBodyOffsets;\n  }\n\n  get lineNumbers(): number {\n    return this.offsets.length;\n  }\n\n  bytecodeOffsetToLineNumber(bytecodeOffset: number): number {\n    let l = 0, r: number = this.offsets.length - 1;\n    while (l <= r) {\n      const m = Math.floor((l + r) / 2);\n      const offset = this.offsets[m];\n      if (offset < bytecodeOffset) {\n        l = m + 1;\n      } else if (offset > bytecodeOffset) {\n        r = m - 1;\n      } else {\n        return m;\n      }\n    }\n    return l;\n  }\n\n  lineNumberToBytecodeOffset(lineNumber: number): number {\n    return this.offsets[lineNumber];\n  }\n\n  /**\n   * returns an iterable enumerating all the non-breakable line numbers in the disassembly\n   */\n  * nonBreakableLineNumbers(): Iterable<number> {\n    let lineNumber = 0;\n    let functionIndex = 0;\n    while (lineNumber < this.lineNumbers) {\n      if (functionIndex < this.functionBodyOffsets.length) {\n        const offset = this.lineNumberToBytecodeOffset(lineNumber);\n        if (offset >= this.functionBodyOffsets[functionIndex].start) {\n          lineNumber = this.bytecodeOffsetToLineNumber(this.functionBodyOffsets[functionIndex++].end);\n          continue;\n        }\n      }\n      yield lineNumber++;\n    }\n  }\n}\n"]}