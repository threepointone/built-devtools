import * as TextUtils from '../../models/text_utils/text_utils.js';
import * as Common from '../common/common.js';
import type * as Protocol from '../../generated/protocol.js';
import type { NetworkRequest } from './NetworkRequest.js';
import type { ResourceTreeFrame, ResourceTreeModel } from './ResourceTreeModel.js';
export declare class Resource implements TextUtils.ContentProvider.ContentProvider {
    private readonly resourceTreeModel;
    private requestInternal;
    private urlInternal;
    private readonly documentURLInternal;
    private readonly frameIdInternal;
    private readonly loaderIdInternal;
    private readonly type;
    private mimeTypeInternal;
    private isGeneratedInternal;
    private lastModifiedInternal;
    private readonly contentSizeInternal;
    private contentInternal;
    private contentLoadError;
    private contentEncodedInternal;
    private readonly pendingContentCallbacks;
    private parsedURLInternal?;
    private contentRequested?;
    constructor(resourceTreeModel: ResourceTreeModel, request: NetworkRequest | null, url: string, documentURL: string, frameId: Protocol.Page.FrameId | null, loaderId: Protocol.Network.LoaderId | null, type: Common.ResourceType.ResourceType, mimeType: string, lastModified: Date | null, contentSize: number | null);
    lastModified(): Date | null;
    contentSize(): number | null;
    get request(): NetworkRequest | null;
    get url(): string;
    set url(x: string);
    get parsedURL(): Common.ParsedURL.ParsedURL | undefined;
    get documentURL(): string;
    get frameId(): Protocol.Page.FrameId | null;
    get loaderId(): Protocol.Network.LoaderId | null;
    get displayName(): string;
    resourceType(): Common.ResourceType.ResourceType;
    get mimeType(): string;
    get content(): string | null;
    get isGenerated(): boolean;
    set isGenerated(val: boolean);
    contentURL(): string;
    contentType(): Common.ResourceType.ResourceType;
    contentEncoded(): Promise<boolean>;
    requestContent(): Promise<TextUtils.ContentProvider.DeferredContent>;
    canonicalMimeType(): string;
    searchInContent(query: string, caseSensitive: boolean, isRegex: boolean): Promise<TextUtils.ContentProvider.SearchMatch[]>;
    populateImageSource(image: HTMLImageElement): Promise<void>;
    private requestFinished;
    private innerRequestContent;
    hasTextContent(): boolean;
    frame(): ResourceTreeFrame | null;
    statusCode(): number;
}
