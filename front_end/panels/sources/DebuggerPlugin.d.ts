import * as Bindings from '../../models/bindings/bindings.js';
import * as Workspace from '../../models/workspace/workspace.js';
import * as SourceFrame from '../../ui/legacy/components/source_frame/source_frame.js';
import type * as TextEditor from '../../ui/legacy/components/text_editor/text_editor.js';
import * as UI from '../../ui/legacy/legacy.js';
import { Plugin } from './Plugin.js';
export declare class DebuggerPlugin extends Plugin {
    private textEditor;
    private uiSourceCode;
    private readonly transformer;
    private executionLocation;
    private controlDown;
    private asyncStepInHoveredLine;
    private asyncStepInHovered;
    private clearValueWidgetsTimer;
    private sourceMapInfobar;
    private controlTimeout;
    private readonly scriptsPanel;
    private readonly breakpointManager;
    private readonly popoverHelper;
    private readonly boundPopoverHelperHide;
    private readonly boundKeyDown;
    private readonly boundKeyUp;
    private readonly boundMouseMove;
    private readonly boundMouseDown;
    private readonly boundBlur;
    private readonly boundWheel;
    private readonly boundGutterClick;
    private readonly breakpointDecorations;
    private readonly decorationByBreakpoint;
    private readonly possibleBreakpointsRequested;
    private scriptFileForDebuggerModel;
    private readonly valueWidgets;
    private continueToLocationDecorations;
    private readonly liveLocationPool;
    private muted;
    private mutedFromStart;
    private ignoreListInfobar;
    private hasLineWithoutMapping;
    private prettyPrintInfobar;
    private scheduledBreakpointDecorationUpdates?;
    constructor(textEditor: SourceFrame.SourcesTextEditor.SourcesTextEditor, uiSourceCode: Workspace.UISourceCode.UISourceCode, transformer: SourceFrame.SourceFrame.Transformer);
    static accepts(uiSourceCode: Workspace.UISourceCode.UISourceCode): boolean;
    private showIgnoreListInfobarIfNeeded;
    private hideIgnoreListInfobar;
    wasShown(): void;
    willHide(): void;
    populateLineGutterContextMenu(contextMenu: UI.ContextMenu.ContextMenu, editorLineNumber: number): Promise<void>;
    populateTextAreaContextMenu(contextMenu: UI.ContextMenu.ContextMenu, editorLineNumber: number, editorColumnNumber: number): Promise<void>;
    private workingCopyChanged;
    private workingCopyCommitted;
    private didMergeToVM;
    private didDivergeFromVM;
    private muteBreakpointsWhileEditing;
    private restoreBreakpointsIfConsistentScripts;
    private restoreBreakpointsAfterEditing;
    private isIdentifier;
    private getPopoverRequest;
    private onWheel;
    private onKeyDown;
    private onMouseMove;
    private setAsyncStepInHoveredLine;
    private onMouseDown;
    private onBlur;
    private onKeyUp;
    private clearControlDown;
    private editBreakpointCondition;
    private executionLineChanged;
    private generateValuesInSource;
    private showContinueToLocations;
    private continueToLocationRenderedForTest;
    private findAsyncStepInRange;
    private asyncStepIn;
    private prepareScopeVariables;
    private renderDecorations;
    private clearExecutionLine;
    private clearValueWidgets;
    private clearContinueToLocationsNoRestore;
    private clearContinueToLocations;
    private lineBreakpointDecorations;
    private breakpointDecoration;
    private updateBreakpointDecoration;
    private breakpointDecorationsUpdatedForTest;
    private inlineBreakpointClick;
    private inlineBreakpointContextMenu;
    private shouldIgnoreExternalBreakpointEvents;
    private breakpointAdded;
    private addBreakpoint;
    private breakpointRemoved;
    private initializeBreakpoints;
    private updateLinesWithoutMappingHighlight;
    private updateScriptFiles;
    private updateScriptFile;
    private showSourceMapInfobar;
    private detectMinified;
    private handleGutterClick;
    private toggleBreakpoint;
    private createNewBreakpoint;
    private setBreakpoint;
    private breakpointWasSetForTest;
    private callFrameChanged;
    dispose(): void;
}
export declare class BreakpointDecoration {
    private textEditor;
    handle: TextEditor.CodeMirrorTextEditor.TextEditorPositionHandle;
    condition: string;
    enabled: boolean;
    bound: boolean;
    breakpoint: Bindings.BreakpointManager.Breakpoint | null;
    element: HTMLSpanElement;
    bookmark: TextEditor.CodeMirrorTextEditor.TextEditorBookMark | null;
    constructor(textEditor: SourceFrame.SourcesTextEditor.SourcesTextEditor, handle: TextEditor.CodeMirrorTextEditor.TextEditorPositionHandle, condition: string, enabled: boolean, bound: boolean, breakpoint: Bindings.BreakpointManager.Breakpoint | null);
    static mostSpecificFirst(decoration1: BreakpointDecoration, decoration2: BreakpointDecoration): number;
    update(): void;
    show(): void;
    hide(): void;
    dispose(): void;
    static readonly bookmarkSymbol: unique symbol;
    private static readonly elementSymbolForTest;
}
export declare const continueToLocationDecorationSymbol: unique symbol;
